<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on Hwajin's Blog</title><link>https://blog.hwajin.me/ko/tags/algorithm/</link><description>Recent content in Algorithm on Hwajin's Blog</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Wed, 10 Jan 2024 00:52:00 +0000</lastBuildDate><atom:link href="https://blog.hwajin.me/ko/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode - 215.Kth Largest Element in an Array</title><link>https://blog.hwajin.me/ko/posts/2024/01/10/leetcode-215-kth-largest-element-in-an-array/</link><pubDate>Wed, 10 Jan 2024 00:52:00 +0000</pubDate><guid>https://blog.hwajin.me/ko/posts/2024/01/10/leetcode-215-kth-largest-element-in-an-array/</guid><description>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Can you solve it without sorting?&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;p>Input: nums = [3,2,1,5,6,4], k = 2
Output: 5&lt;/p>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;p>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>정렬을 사용하지 못한다. 우선 나는 $$-10^4 &amp;lt;= N &amp;lt;= 10^4$$ 가 보장되었다 하였으니, 공간복잡도를 포기하고 풀었다. $$O(2n)$$&lt;/p></description><content>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Can you solve it without sorting?&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;p>Input: nums = [3,2,1,5,6,4], k = 2
Output: 5&lt;/p>
&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;p>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>정렬을 사용하지 못한다. 우선 나는 $$-10^4 &amp;lt;= N &amp;lt;= 10^4$$ 가 보장되었다 하였으니, 공간복잡도를 포기하고 풀었다. $$O(2n)$$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MAGIC &lt;span style="color:#f92672">=&lt;/span> 10000;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findKthLargest&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> order &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>20001&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> num : nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order&lt;span style="color:#f92672">[&lt;/span>num &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> (num &lt;span style="color:#f92672">+&lt;/span> MAGIC) : num &lt;span style="color:#f92672">+&lt;/span> MAGIC&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> order.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1, m &lt;span style="color:#f92672">=&lt;/span> k, s &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0; &lt;span style="color:#f92672">--&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (order&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#f92672">-=&lt;/span> order&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (m &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> MAGIC &lt;span style="color:#f92672">?&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> MAGIC : i &lt;span style="color:#f92672">-&lt;/span> MAGIC;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Rotate Array</title><link>https://blog.hwajin.me/ko/posts/2022/04/29/leetcode-rotate-array/</link><pubDate>Fri, 29 Apr 2022 01:31:12 +0000</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/29/leetcode-rotate-array/</guid><description>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>Given an array, rotate the array to the right by &lt;code>k&lt;/code> steps, where &lt;code>k&lt;/code> is non-negative.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p></description><content>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>Given an array, rotate the array to the right by &lt;code>k&lt;/code> steps, where &lt;code>k&lt;/code> is non-negative.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code>&lt;/li>
&lt;li>&lt;code>-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1&lt;/code>&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= k &amp;lt;= 10^5&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Follow up:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Try to come up with as many solutions as you can. There are at least &lt;strong>three&lt;/strong> different ways to solve this problem.&lt;/li>
&lt;li>Could you do it in-place with &lt;code>O(1)&lt;/code> extra space?&lt;/li>
&lt;/ul>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>자, 배열 &lt;code>[1,2,3,4,5,6,7]&lt;/code> 를 잘 살펴보자. &lt;code>k=3&lt;/code> 일 때, 결과가 &lt;code>[5,6,7,1,2,3,4]&lt;/code> 라면, &lt;code>1,2,3,4&lt;/code> 와 &lt;code>5,6,7&lt;/code> 을 따로 두고 생각할 수 있을 것이다.&lt;/p>
&lt;p>그렇다면, 극강의 꼼수를 부려볼 수 있다. 왜냐하면, 잘 봐라. &amp;ldquo;Rotate&amp;rdquo; 라고 하지 않는가. 일단 뒤집고 생각해보자.&lt;/p>
&lt;p>&lt;code>[7,6,5,4,3,2,1]&lt;/code> 를 잘 보면 해답이 보인다. 바로 &lt;code>k=3&lt;/code> 이라는 점에서, 우리는 이 뒤집어진 배열을 두 번만 더 뒤집으면 끝난다. 어딜 기점으로? &lt;code>k=3&lt;/code> 즉, &lt;code>k - 1&lt;/code> 을 기준으로.&lt;/p>
&lt;p>그런데, 놀랍게도 &lt;code>k&lt;/code> 는 &lt;code>10^5&lt;/code> 까지 입력을 받을 수 있다. 즉, &lt;code>nums.length&lt;/code> 보다 더 클 수 있다. 이러면 당연히 에러가 발생한다. 나머지 연산을 통해서 N값보다 클 때 언제나 N값으로 나눈 나머지, 즉 실제 우리가 회전시켜야 하는 수만 뽑아낼 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">rotate&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">==&lt;/span> 1 &lt;span style="color:#f92672">||&lt;/span> k &lt;span style="color:#f92672">==&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reverse(nums, 0, nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reverse(nums, 0, k &lt;span style="color:#f92672">%&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reverse(nums, k &lt;span style="color:#f92672">%&lt;/span> nums.&lt;span style="color:#a6e22e">length&lt;/span>, nums.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">reverse&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> l, &lt;span style="color:#66d9ef">int&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (l &lt;span style="color:#f92672">&amp;lt;&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">[&lt;/span>l&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n&lt;span style="color:#f92672">[&lt;/span>l&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">[&lt;/span>r&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n&lt;span style="color:#f92672">[&lt;/span>r&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>l;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span>r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>참고로 이 접근법은 엄청난 논쟁을 야기시킨 방법이었다.. 이 글 쓰면서 Solution 보고 알았다.&lt;/p></content></item><item><title>Leetcode - Merge Intervals</title><link>https://blog.hwajin.me/ko/posts/2022/04/06/leetcode-merge-intervals/</link><pubDate>Wed, 06 Apr 2022 23:29:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/06/leetcode-merge-intervals/</guid><description>&lt;p>Given an array of &lt;code>intervals&lt;/code> where &lt;code>intervals[i] = [starti, endi]&lt;/code>, merge all overlapping intervals, and return &lt;em>an array of the non-overlapping intervals that cover all the intervals in the input&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= intervals.length &amp;lt;= 104&lt;/code>&lt;/li>
&lt;li>&lt;code>intervals[i].length == 2&lt;/code>&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= starti &amp;lt;= endi &amp;lt;= 104&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>&lt;code>[1,3], [2,4]&lt;/code> 와 같이 정렬되어 있을 때 &lt;code>[i][0]&lt;/code> 은 &lt;code>[i - 1][1]&lt;/code> 보다 작을 때 범위에 속한 것이니, 정렬만 있다면 문제가 없다.&lt;/p></description><content>&lt;p>Given an array of &lt;code>intervals&lt;/code> where &lt;code>intervals[i] = [starti, endi]&lt;/code>, merge all overlapping intervals, and return &lt;em>an array of the non-overlapping intervals that cover all the intervals in the input&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= intervals.length &amp;lt;= 104&lt;/code>&lt;/li>
&lt;li>&lt;code>intervals[i].length == 2&lt;/code>&lt;/li>
&lt;li>&lt;code>0 &amp;lt;= starti &amp;lt;= endi &amp;lt;= 104&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>&lt;code>[1,3], [2,4]&lt;/code> 와 같이 정렬되어 있을 때 &lt;code>[i][0]&lt;/code> 은 &lt;code>[i - 1][1]&lt;/code> 보다 작을 때 범위에 속한 것이니, 정렬만 있다면 문제가 없다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> &lt;span style="color:#a6e22e">merge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> arr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (arr.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 2) &lt;span style="color:#66d9ef">return&lt;/span> arr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Arrays.&lt;span style="color:#a6e22e">sort&lt;/span>(arr, &lt;span style="color:#66d9ef">new&lt;/span> Comparator&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">compare&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> 0, ok &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> arr.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (arr&lt;span style="color:#f92672">[&lt;/span>t&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> arr&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr&lt;span style="color:#f92672">[&lt;/span>t&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(arr&lt;span style="color:#f92672">[&lt;/span>t&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>, arr&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>ok;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>ok&lt;span style="color:#f92672">][&lt;/span>2&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> 0, p &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (c &lt;span style="color:#f92672">&amp;lt;&lt;/span> ok) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (arr&lt;span style="color:#f92672">[&lt;/span>p&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1) { &lt;span style="color:#f92672">++&lt;/span>p; &lt;span style="color:#66d9ef">continue&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">[&lt;/span>c&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> arr&lt;span style="color:#f92672">[&lt;/span>p&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">[&lt;/span>c&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> arr&lt;span style="color:#f92672">[&lt;/span>p&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayList 같이 &lt;code>List&lt;/code> 자료구조를 안써서 짜봤다.&lt;/p></content></item><item><title>Leetcode - Maximum Length of a Concatenated String with Unique Characters</title><link>https://blog.hwajin.me/ko/posts/2022/04/05/leetcode-maximum-length-of-a-concatenated-string-with-unique-characters/</link><pubDate>Wed, 06 Apr 2022 21:46:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/05/leetcode-maximum-length-of-a-concatenated-string-with-unique-characters/</guid><description>&lt;p>You are given an array of strings &lt;code>arr&lt;/code>. A string &lt;code>s&lt;/code> is formed by the &lt;strong>concatenation&lt;/strong> of a &lt;strong>subsequence&lt;/strong> of &lt;code>arr&lt;/code> that has &lt;strong>unique characters&lt;/strong>.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>maximum&lt;/strong> possible length&lt;/em> of &lt;code>s&lt;/code>.&lt;/p>
&lt;p>A &lt;strong>subsequence&lt;/strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: arr = [&amp;#34;un&amp;#34;,&amp;#34;iq&amp;#34;,&amp;#34;ue&amp;#34;]
Output: 4
Explanation: All the valid concatenations are:
- &amp;#34;&amp;#34;
- &amp;#34;un&amp;#34;
- &amp;#34;iq&amp;#34;
- &amp;#34;ue&amp;#34;
- &amp;#34;uniq&amp;#34; (&amp;#34;un&amp;#34; + &amp;#34;iq&amp;#34;)
- &amp;#34;ique&amp;#34; (&amp;#34;iq&amp;#34; + &amp;#34;ue&amp;#34;)
Maximum length is 4.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description><content>&lt;p>You are given an array of strings &lt;code>arr&lt;/code>. A string &lt;code>s&lt;/code> is formed by the &lt;strong>concatenation&lt;/strong> of a &lt;strong>subsequence&lt;/strong> of &lt;code>arr&lt;/code> that has &lt;strong>unique characters&lt;/strong>.&lt;/p>
&lt;p>Return &lt;em>the &lt;strong>maximum&lt;/strong> possible length&lt;/em> of &lt;code>s&lt;/code>.&lt;/p>
&lt;p>A &lt;strong>subsequence&lt;/strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: arr = [&amp;#34;un&amp;#34;,&amp;#34;iq&amp;#34;,&amp;#34;ue&amp;#34;]
Output: 4
Explanation: All the valid concatenations are:
- &amp;#34;&amp;#34;
- &amp;#34;un&amp;#34;
- &amp;#34;iq&amp;#34;
- &amp;#34;ue&amp;#34;
- &amp;#34;uniq&amp;#34; (&amp;#34;un&amp;#34; + &amp;#34;iq&amp;#34;)
- &amp;#34;ique&amp;#34; (&amp;#34;iq&amp;#34; + &amp;#34;ue&amp;#34;)
Maximum length is 4.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: arr = [&amp;#34;cha&amp;#34;,&amp;#34;r&amp;#34;,&amp;#34;act&amp;#34;,&amp;#34;ers&amp;#34;]
Output: 6
Explanation: Possible longest valid concatenations are &amp;#34;chaers&amp;#34; (&amp;#34;cha&amp;#34; + &amp;#34;ers&amp;#34;) and &amp;#34;acters&amp;#34; (&amp;#34;act&amp;#34; + &amp;#34;ers&amp;#34;).
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: arr = [&amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34;]
Output: 26
Explanation: The only string in arr has all 26 characters.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Constraints:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>1 &amp;lt;= arr.length &amp;lt;= 16&lt;/code>&lt;/li>
&lt;li>&lt;code>1 &amp;lt;= arr[i].length &amp;lt;= 26&lt;/code>&lt;/li>
&lt;li>&lt;code>arr[i]&lt;/code> contains only lowercase English letters.&lt;/li>
&lt;/ul>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>면접때 못푼 문제 (..). 좀 고민하니까 풀리긴 했는데, 잊을만 할 때 다시 풀어봐야겠다. 우선, String 을 풀어서 문자로 바꿔야 한다. Bitmask 를 사용하면 추가 공간을 크게 잡아먹지 않는다.&lt;/p>
&lt;ol>
&lt;li>ASCII 코드상에서 a&lt;del>z는 26개. Java 의 int 는 32bit 라서 시프트 연산으로 a&lt;/del>z를 숫자로 변환 후 마스킹한다&lt;/li>
&lt;li>전부 마스킹 후 체크를 시작한다.&lt;/li>
&lt;li>지금 보는 노드보다 전의 노드는 볼 필요가 없다.&lt;/li>
&lt;li>하위 노드도 동일한 규칙을 가진다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxLength&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>val.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> val.&lt;span style="color:#a6e22e">size&lt;/span>(); &lt;span style="color:#f92672">++&lt;/span>i) arr&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> stringToBitmask(val.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> check(arr, 0, 0, 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">stringToBitmask&lt;/span>(String str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">toCharArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mask &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span> item : arr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (1 &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> item &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask &lt;span style="color:#f92672">+=&lt;/span> 1 &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> (item &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">check&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> items, &lt;span style="color:#66d9ef">int&lt;/span> me, &lt;span style="color:#66d9ef">int&lt;/span> position, &lt;span style="color:#66d9ef">int&lt;/span> max) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> position; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> items.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((me &lt;span style="color:#f92672">&amp;amp;&lt;/span> items&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(max, check(items, me &lt;span style="color:#f92672">+&lt;/span> items&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>, i &lt;span style="color:#f92672">+&lt;/span> 1, Math.&lt;span style="color:#a6e22e">max&lt;/span>(max, Integer.&lt;span style="color:#a6e22e">bitCount&lt;/span>(me &lt;span style="color:#f92672">+&lt;/span> items&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>))));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> max;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img alt="Leetcode" src="https://user-images.githubusercontent.com/8151366/161979785-b54db03c-f35f-4bfb-baee-850687f29dfd.png">&lt;/p>
&lt;p>Leetcode 는 Runtime이 지맘대로라 믿을 수가 없다(..)&lt;/p>
&lt;p>백트래킹에 약해서 더 풀어봐야겠다. 사실 그래프 탐색 다 못하는편.&lt;/p></content></item><item><title>Leetcode - Average Salary Excluding the Minimum and Maximum Salary</title><link>https://blog.hwajin.me/ko/posts/2022/04/05/leetcode-average-salary-excluding-the-minimum-and-maximum-salary/</link><pubDate>Tue, 05 Apr 2022 23:41:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/05/leetcode-average-salary-excluding-the-minimum-and-maximum-salary/</guid><description>&lt;p>You are given an array of &lt;strong>unique&lt;/strong> integers &lt;code>salary&lt;/code> where &lt;code>salary[i]&lt;/code> is the salary of the &lt;code>ith&lt;/code>employee.&lt;/p>
&lt;p>Return &lt;em>the average salary of employees excluding the minimum and maximum salary&lt;/em>. Answers within &lt;code>10-5&lt;/code> of the actual answer will be accepted.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description><content>&lt;p>You are given an array of &lt;strong>unique&lt;/strong> integers &lt;code>salary&lt;/code> where &lt;code>salary[i]&lt;/code> is the salary of the &lt;code>ith&lt;/code>employee.&lt;/p>
&lt;p>Return &lt;em>the average salary of employees excluding the minimum and maximum salary&lt;/em>. Answers within &lt;code>10-5&lt;/code> of the actual answer will be accepted.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000) / 1 = 2000
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>첨에는 딱 중간 값만 뽑으면 TC가 $$O(n \log_n)$$ 이라서 개꿀 이랬는데 음~ 문제 읽고 바로 나의 착각이란걸 알았죠~&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">average&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> salary) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> min &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span>, max &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">MIN_VALUE&lt;/span>, sl &lt;span style="color:#f92672">=&lt;/span> salary.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> sl; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(min, salary&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(max, salary&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s &lt;span style="color:#f92672">+=&lt;/span> salary&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (s &lt;span style="color:#f92672">-&lt;/span> min &lt;span style="color:#f92672">-&lt;/span> max) &lt;span style="color:#f92672">/&lt;/span> (salary.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Count Odd Numbers in an Interval Range</title><link>https://blog.hwajin.me/ko/posts/2022/04/05/leetcode-count-odd-numbers-in-an-interval-range/</link><pubDate>Tue, 05 Apr 2022 23:41:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/05/leetcode-count-odd-numbers-in-an-interval-range/</guid><description>&lt;p>Given two non-negative integers &lt;code>low&lt;/code> and &lt;code>high&lt;/code>. Return the &lt;em>count of odd numbers between&lt;/em> &lt;code>low&lt;/code> &lt;em>and&lt;/em> &lt;code>high&lt;/code> &lt;em>(inclusive)&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>생각하지 않고 풀었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">countOdds&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> low, &lt;span style="color:#66d9ef">int&lt;/span> high) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0) low &lt;span style="color:#f92672">+=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (high &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0) high &lt;span style="color:#f92672">-=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (high &lt;span style="color:#f92672">-&lt;/span> low &lt;span style="color:#f92672">==&lt;/span> 0) &lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((high &lt;span style="color:#f92672">-&lt;/span> low) &lt;span style="color:#f92672">/&lt;/span> 2) &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content>&lt;p>Given two non-negative integers &lt;code>low&lt;/code> and &lt;code>high&lt;/code>. Return the &lt;em>count of odd numbers between&lt;/em> &lt;code>low&lt;/code> &lt;em>and&lt;/em> &lt;code>high&lt;/code> &lt;em>(inclusive)&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>생각하지 않고 풀었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">countOdds&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> low, &lt;span style="color:#66d9ef">int&lt;/span> high) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0) low &lt;span style="color:#f92672">+=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (high &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0) high &lt;span style="color:#f92672">-=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (high &lt;span style="color:#f92672">-&lt;/span> low &lt;span style="color:#f92672">==&lt;/span> 0) &lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((high &lt;span style="color:#f92672">-&lt;/span> low) &lt;span style="color:#f92672">/&lt;/span> 2) &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Add Two Numbers</title><link>https://blog.hwajin.me/ko/posts/2022/04/04/leetcode-add-two-numbers/</link><pubDate>Mon, 04 Apr 2022 23:18:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/04/leetcode-add-two-numbers/</guid><description>&lt;p>You are given two &lt;strong>non-empty&lt;/strong> linked lists representing two non-negative integers. The digits are stored in &lt;strong>reverse order&lt;/strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;/p>
&lt;p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description><content>&lt;p>You are given two &lt;strong>non-empty&lt;/strong> linked lists representing two non-negative integers. The digits are stored in &lt;strong>reverse order&lt;/strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&lt;/p>
&lt;p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: l1 = [0], l2 = [0]
Output: [0]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>Reverse Order 라길래 멍청하게 처음에는 Stack 으로 짰다 (..). 무척이나 개발자 스럽게도 &lt;code>0&lt;/code> 번 인덱스를 고려한 것이었다. 제발 이런 멍청한 실수는 하지 말자.&lt;/p>
&lt;p>연결 리스트를 끝까지 탐색하며 더하면 끝.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ListNode &lt;span style="color:#a6e22e">addTwoNumbers&lt;/span>(ListNode l1, ListNode l2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode p1 &lt;span style="color:#f92672">=&lt;/span> l1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode p2 &lt;span style="color:#f92672">=&lt;/span> l2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(&lt;span style="color:#f92672">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode ret &lt;span style="color:#f92672">=&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> carry &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (p1 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> p2 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> (p1 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> p1.&lt;span style="color:#a6e22e">val&lt;/span> : 0) &lt;span style="color:#f92672">+&lt;/span> (p2 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> p2.&lt;span style="color:#a6e22e">val&lt;/span> : 0) &lt;span style="color:#f92672">+&lt;/span> carry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(val &lt;span style="color:#f92672">%&lt;/span> 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> result.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carry &lt;span style="color:#f92672">=&lt;/span> val &lt;span style="color:#f92672">/&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p1 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) p1 &lt;span style="color:#f92672">=&lt;/span> p1.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p2 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) p2 &lt;span style="color:#f92672">=&lt;/span> p2.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (carry &lt;span style="color:#f92672">!=&lt;/span> 0) result.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Swap Nodes In Pairs</title><link>https://blog.hwajin.me/ko/posts/2022/04/04/leetcode-swap-nodes-in-pairs/</link><pubDate>Mon, 04 Apr 2022 23:18:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/04/leetcode-swap-nodes-in-pairs/</guid><description>&lt;p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = [1,2,3,4]
Output: [2,1,4,3]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = []
Output: []
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = [1]
Output: [1]
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>일단 통과했으니 올리고, 한 달 후에 다시 풀어봐야겠다. &lt;code>jump&lt;/code> 때문에 더러워졌어..&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ListNode &lt;span style="color:#a6e22e">swapPairs&lt;/span>(ListNode head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode eNode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(&lt;span style="color:#f92672">-&lt;/span>1, head &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> head.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> head.&lt;span style="color:#a6e22e">next&lt;/span> : head);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode target &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode before &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode jump &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (target &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">!=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jump &lt;span style="color:#f92672">=&lt;/span> before;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before &lt;span style="color:#f92672">=&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode temp &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> before;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (jump &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) jump.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> eNode.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content>&lt;p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = [1,2,3,4]
Output: [2,1,4,3]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = []
Output: []
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: head = [1]
Output: [1]
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>일단 통과했으니 올리고, 한 달 후에 다시 풀어봐야겠다. &lt;code>jump&lt;/code> 때문에 더러워졌어..&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ListNode &lt;span style="color:#a6e22e">swapPairs&lt;/span>(ListNode head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode eNode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(&lt;span style="color:#f92672">-&lt;/span>1, head &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> head.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> head.&lt;span style="color:#a6e22e">next&lt;/span> : head);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode target &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode before &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode jump &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (target &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">!=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jump &lt;span style="color:#f92672">=&lt;/span> before;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before &lt;span style="color:#f92672">=&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode temp &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> before;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (jump &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) jump.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> eNode.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Add Strings</title><link>https://blog.hwajin.me/ko/posts/2022/04/02/leetcode-add-strings/</link><pubDate>Sat, 02 Apr 2022 03:55:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/02/leetcode-add-strings/</guid><description>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>Given two non-negative integers, &lt;code>num1&lt;/code> and &lt;code>num2&lt;/code> represented as string, return &lt;em>the sum of&lt;/em> &lt;code>num1&lt;/code> &lt;em>and&lt;/em>&lt;code>num2&lt;/code> &lt;em>as a string&lt;/em>.&lt;/p>
&lt;p>You must solve the problem without using any built-in library for handling large integers (such as &lt;code>BigInteger&lt;/code>). &lt;strong>You must also not convert the inputs to integers directly.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: num1 = &amp;#34;11&amp;#34;, num2 = &amp;#34;123&amp;#34;
Output: &amp;#34;134&amp;#34;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: num1 = &amp;#34;456&amp;#34;, num2 = &amp;#34;77&amp;#34;
Output: &amp;#34;533&amp;#34;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: num1 = &amp;#34;0&amp;#34;, num2 = &amp;#34;0&amp;#34;
Output: &amp;#34;0&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>난이도 최하의 문제로 뒤에서 하나씩 더해가면 끝이다. 산수의 영역(..)&lt;/p></description><content>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>Given two non-negative integers, &lt;code>num1&lt;/code> and &lt;code>num2&lt;/code> represented as string, return &lt;em>the sum of&lt;/em> &lt;code>num1&lt;/code> &lt;em>and&lt;/em>&lt;code>num2&lt;/code> &lt;em>as a string&lt;/em>.&lt;/p>
&lt;p>You must solve the problem without using any built-in library for handling large integers (such as &lt;code>BigInteger&lt;/code>). &lt;strong>You must also not convert the inputs to integers directly.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: num1 = &amp;#34;11&amp;#34;, num2 = &amp;#34;123&amp;#34;
Output: &amp;#34;134&amp;#34;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: num1 = &amp;#34;456&amp;#34;, num2 = &amp;#34;77&amp;#34;
Output: &amp;#34;533&amp;#34;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: num1 = &amp;#34;0&amp;#34;, num2 = &amp;#34;0&amp;#34;
Output: &amp;#34;0&amp;#34;
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>난이도 최하의 문제로 뒤에서 하나씩 더해가면 끝이다. 산수의 영역(..)&lt;/p>
&lt;ol>
&lt;li>&lt;code>num1&lt;/code> 의 마지막 원소와 &lt;code>num2&lt;/code> 의 마지막 원소를 더한다&lt;/li>
&lt;li>두 집합 모두 같은 방식으로 순회하며 더한다&lt;/li>
&lt;/ol>
&lt;p>더할 때 9를 초과하는 수가 나올 수 있다. 예를 들어 보자&lt;/p>
&lt;pre tabindex="0">&lt;code>num1 = &amp;#34;999&amp;#34;
num2 = &amp;#34;99999&amp;#34;
&lt;/code>&lt;/pre>&lt;p>이렇다면,&lt;/p>
&lt;pre tabindex="0">&lt;code>9 + 9 = 18
1 + 9 + 9 = 19
1 + 9 + 9 = 19
...
&lt;/code>&lt;/pre>&lt;p>그러니 10을 나눈 나머지를 값으로 쓰고, 나눈 값을 올린다. 뭐 편한대로 (..) 걍 1 올려도 상관 없고요. &lt;code>carry = twoSum &amp;gt; 9 ? 1 : 0;&lt;/code> 이래도 괜찮은데 뭐.. 내 취향은 아니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">addStrings&lt;/span>(String num1, String num2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> alpha &lt;span style="color:#f92672">=&lt;/span> num1.&lt;span style="color:#a6e22e">toCharArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> beta &lt;span style="color:#f92672">=&lt;/span> num2.&lt;span style="color:#a6e22e">toCharArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> alphaSize &lt;span style="color:#f92672">=&lt;/span> alpha.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> betaSize &lt;span style="color:#f92672">=&lt;/span> beta.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> carry &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (alphaSize &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> betaSize &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> aResult &lt;span style="color:#f92672">=&lt;/span> alphaSize &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> alpha&lt;span style="color:#f92672">[&lt;/span>alphaSize&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> : 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> bResult &lt;span style="color:#f92672">=&lt;/span> betaSize &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> beta&lt;span style="color:#f92672">[&lt;/span>betaSize&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> : 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> twoSum &lt;span style="color:#f92672">=&lt;/span> aResult &lt;span style="color:#f92672">+&lt;/span> bResult &lt;span style="color:#f92672">+&lt;/span> carry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> twoSum &lt;span style="color:#f92672">%&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carry &lt;span style="color:#f92672">=&lt;/span> val &lt;span style="color:#f92672">/&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span>alphaSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span>betaSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (carry &lt;span style="color:#f92672">!=&lt;/span> 0) result.&lt;span style="color:#a6e22e">append&lt;/span>(carry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.&lt;span style="color:#a6e22e">reverse&lt;/span>().&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>극강의 효율을 원한다면 Native array 를 써도 괜찮을 것 같다. 다만 배열 사이즈 늘리는게 귀찮다.&lt;/p>
&lt;hr>
&lt;p>공간 복잡도의 경우 $$O(max(n, m))$$ 이긴 하다. 자리가 바뀌는 경우가 생기니 1을 더하는 것도 맞다. Big-O 표기법에 안맞을 뿐.&lt;/p></content></item><item><title>Leetcode - Two Sum</title><link>https://blog.hwajin.me/ko/posts/2022/04/01/leetcode-two-sum/</link><pubDate>Fri, 01 Apr 2022 19:43:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/01/leetcode-two-sum/</guid><description>&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>target&lt;/code>, return &lt;em>indices of the two numbers such that they add up to &lt;code>target&lt;/code>&lt;/em>. You may assume that each input would have *&lt;strong>exactly* one solution&lt;/strong>, and you may not use the &lt;em>same&lt;/em> element twice.&lt;/p>
&lt;p>You can return the answer in any order.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p></description><content>&lt;p>Given an array of integers &lt;code>nums&lt;/code> and an integer &lt;code>target&lt;/code>, return &lt;em>indices of the two numbers such that they add up to &lt;code>target&lt;/code>&lt;/em>. You may assume that each input would have *&lt;strong>exactly* one solution&lt;/strong>, and you may not use the &lt;em>same&lt;/em> element twice.&lt;/p>
&lt;p>You can return the answer in any order.&lt;/p>
&lt;p>&lt;strong>Example 1:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 2:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [3,2,4], target = 6
Output: [1,2]
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Example 3:&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>Input: nums = [3,3], target = 6
Output: [0,1]
&lt;/code>&lt;/pre>&lt;h2 id="solution">Solution,&lt;/h2>
&lt;ol>
&lt;li>먼저 모두 순회시켜서 Map 에 넣는다&lt;/li>
&lt;li>다시 순회하면서 계산해본다&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">twoSum&lt;/span>(nums: IntArray, target: Int): IntArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> temp = mutableMapOf&amp;lt;Int, Int&amp;gt;();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ((i, v) &lt;span style="color:#66d9ef">in&lt;/span> nums.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp.put(v, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ((i, v) &lt;span style="color:#66d9ef">in&lt;/span> nums.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (temp.contains(target - v) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> temp.&lt;span style="color:#66d9ef">get&lt;/span>(target - v)&lt;span style="color:#f92672">!!&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> intArrayOf(temp.&lt;span style="color:#66d9ef">get&lt;/span>(target - v)&lt;span style="color:#f92672">!!&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> intArrayOf()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Valid Sudoku</title><link>https://blog.hwajin.me/ko/posts/2022/04/01/leetcode-valid-sudoku/</link><pubDate>Fri, 01 Apr 2022 15:58:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/04/01/leetcode-valid-sudoku/</guid><description>&lt;p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p>
&lt;p>Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:&lt;/p>
&lt;p>A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.&lt;/p></description><content>&lt;p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p>
&lt;p>Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:&lt;/p>
&lt;p>A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.&lt;/p>
&lt;p>&lt;img alt="Leetcode" src="https://user-images.githubusercontent.com/8151366/161214870-77d62353-e26a-4dab-b2f2-2eb8cebe97f4.png">&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>다른 방법도 몇 있는 것 같던데 나는 비트 연산으로 풀었다. 추가 공간을 크게 먹지 않는다.&lt;/p>
&lt;p>행, 열, 박스를 체크해야 한다. 시프트 연산으로 각 비트에 플래그를 걸고 현재 행/열/박스 와 AND 연산시 비트가 존재하는가 존재하지 않는가로 검사한다. 왜냐면, 이미 해당 비트(숫자)가 있다면 &lt;code>true&lt;/code> 일 테니.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isValidSudoku&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> board) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> row &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>9&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> col &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>9&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> box &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>9&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 9; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> 9; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (board&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> boxpos &lt;span style="color:#f92672">=&lt;/span> ((i &lt;span style="color:#f92672">/&lt;/span> 3) &lt;span style="color:#f92672">*&lt;/span> 3) &lt;span style="color:#f92672">+&lt;/span> (j &lt;span style="color:#f92672">/&lt;/span> 3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> 1 &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ((&lt;span style="color:#66d9ef">int&lt;/span>) board&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((row&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> t) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0 &lt;span style="color:#f92672">||&lt;/span> (col&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> t) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0 &lt;span style="color:#f92672">||&lt;/span> (box&lt;span style="color:#f92672">[&lt;/span>boxpos&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> t) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> row&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> col&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> box&lt;span style="color:#f92672">[&lt;/span>boxpos&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">|=&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</title><link>https://blog.hwajin.me/ko/posts/2022/03/31/leetcode-maximum-area-of-a-piece-of-cake/</link><pubDate>Thu, 31 Mar 2022 20:41:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/03/31/leetcode-maximum-area-of-a-piece-of-cake/</guid><description>&lt;p>You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:&lt;/p>
&lt;p>horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and
verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.
Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.&lt;/p></description><content>&lt;p>You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:&lt;/p>
&lt;p>horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and
verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.
Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.&lt;/p>
&lt;p>&lt;img alt="Leetcode" src="https://user-images.githubusercontent.com/8151366/161118991-15352994-9a21-4a1b-afad-70b85dbb3680.png">&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>오늘 본 코딩 테스트에서 나온 문제인데, 이야 이걸 못풀었다는게 참 멍청했다. 우선, &lt;code>hc&lt;/code> 와 &lt;code>vc&lt;/code> 가 정렬되어 있다는 가정 하에 (안되어 있을 수 있으니 정렬 때리고) 시작한다.&lt;/p>
&lt;p>사람은 태어나 서울로 보내라 하던가. 얘도 결국 핵심은 하나다. 모든 경우의 수를 다 탐색할 이유가 없다.&lt;/p>
&lt;ol>
&lt;li>내가 이 케잌의 끝을 안다&lt;/li>
&lt;li>잘리는 범위를 안다&lt;/li>
&lt;/ol>
&lt;p>즉, 최대로 자를 수 있는 범위를 우선 구한다. 그리고 내가 자른 것보다 남은게 더 크면 그게 최대 값일 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.math.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxArea&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> h, &lt;span style="color:#66d9ef">int&lt;/span> w, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> hc, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> vc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Arrays.&lt;span style="color:#a6e22e">sort&lt;/span>(hc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Arrays.&lt;span style="color:#a6e22e">sort&lt;/span>(vc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curHeight &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> maxHeight &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> hc.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHeight &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(hc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> curHeight, maxHeight);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curHeight &lt;span style="color:#f92672">=&lt;/span> hc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> curWidth &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> maxWidth &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> vc.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxWidth &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(vc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-&lt;/span> curWidth, maxWidth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curWidth &lt;span style="color:#f92672">=&lt;/span> vc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxWidth &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(maxWidth, w &lt;span style="color:#f92672">-&lt;/span> vc&lt;span style="color:#f92672">[&lt;/span>vc.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxHeight &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(maxHeight, h &lt;span style="color:#f92672">-&lt;/span> hc&lt;span style="color:#f92672">[&lt;/span>hc.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> maxHeight &lt;span style="color:#f92672">*&lt;/span> maxWidth;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>) ((maxHeight &lt;span style="color:#f92672">*&lt;/span> maxWidth) &lt;span style="color:#f92672">%&lt;/span> 1000000007);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>시간 복잡도는 &lt;code>O(n + log n + m + log m)&lt;/code> 정도 같다.&lt;/p>
&lt;p>집에서 10분에 푼걸 못푸네.. 삶이란 참 기구한 법이다..&lt;/p></content></item><item><title>Leetcode - Custom Sort String</title><link>https://blog.hwajin.me/ko/posts/2022/03/28/leetcode-custom-sort-string/</link><pubDate>Mon, 28 Mar 2022 21:44:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/03/28/leetcode-custom-sort-string/</guid><description>&lt;p>Permute the characters of &lt;code>s&lt;/code> so that they match the order that &lt;code>order&lt;/code> was sorted. More specifically, if a character &lt;code>x&lt;/code> occurs before a character &lt;code>y&lt;/code> in &lt;code>order&lt;/code>, then &lt;code>x&lt;/code> should occur before &lt;code>y&lt;/code> in the permuted string.&lt;/p>
&lt;p>Return &lt;em>any permutation of&lt;/em> &lt;code>s&lt;/code> &lt;em>that satisfies this property&lt;/em>.&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>교집합만 뽑아내서 하면 된다. 이것도 하도 옛날에 풀어서 다시 풀면 더 이쁘게 할 수 있을 것 같다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">customSortString&lt;/span>(String order, String str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer, Character&lt;span style="color:#f92672">&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Character, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> o &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> order.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o.&lt;span style="color:#a6e22e">put&lt;/span>(order.&lt;span style="color:#a6e22e">charAt&lt;/span>(i), i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.&lt;span style="color:#a6e22e">put&lt;/span>(i, order.&lt;span style="color:#a6e22e">charAt&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> str.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> item &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">charAt&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o.&lt;span style="color:#a6e22e">containsKey&lt;/span>(item)) j.&lt;span style="color:#a6e22e">add&lt;/span>(o.&lt;span style="color:#a6e22e">get&lt;/span>(item));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> result.&lt;span style="color:#a6e22e">append&lt;/span>(item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collections.&lt;span style="color:#a6e22e">sort&lt;/span>(j);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(Integer item : j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(a.&lt;span style="color:#a6e22e">get&lt;/span>(item));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description><content>&lt;p>Permute the characters of &lt;code>s&lt;/code> so that they match the order that &lt;code>order&lt;/code> was sorted. More specifically, if a character &lt;code>x&lt;/code> occurs before a character &lt;code>y&lt;/code> in &lt;code>order&lt;/code>, then &lt;code>x&lt;/code> should occur before &lt;code>y&lt;/code> in the permuted string.&lt;/p>
&lt;p>Return &lt;em>any permutation of&lt;/em> &lt;code>s&lt;/code> &lt;em>that satisfies this property&lt;/em>.&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>교집합만 뽑아내서 하면 된다. 이것도 하도 옛날에 풀어서 다시 풀면 더 이쁘게 할 수 있을 것 같다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">customSortString&lt;/span>(String order, String str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer, Character&lt;span style="color:#f92672">&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Character, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> o &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> order.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> o.&lt;span style="color:#a6e22e">put&lt;/span>(order.&lt;span style="color:#a6e22e">charAt&lt;/span>(i), i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.&lt;span style="color:#a6e22e">put&lt;/span>(i, order.&lt;span style="color:#a6e22e">charAt&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> str.&lt;span style="color:#a6e22e">length&lt;/span>(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> item &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">charAt&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o.&lt;span style="color:#a6e22e">containsKey&lt;/span>(item)) j.&lt;span style="color:#a6e22e">add&lt;/span>(o.&lt;span style="color:#a6e22e">get&lt;/span>(item));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> result.&lt;span style="color:#a6e22e">append&lt;/span>(item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collections.&lt;span style="color:#a6e22e">sort&lt;/span>(j);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(Integer item : j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(a.&lt;span style="color:#a6e22e">get&lt;/span>(item));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>Leetcode - Longest Substring Without Repeating Charactes</title><link>https://blog.hwajin.me/ko/posts/2022/03/28/leetcode-longest-substring-without-repeating/</link><pubDate>Mon, 28 Mar 2022 20:12:00 +0900</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/03/28/leetcode-longest-substring-without-repeating/</guid><description>&lt;p>문자열 &lt;code>s&lt;/code> 가 주어졌을 때 겹치는 문자가 없는 부분 문자열의 길이를 반환하라.&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>보자마자 알 수 있었다. Sliding Window 로 풀 수 있다는 것을. Two Pointer 알고리즘은 워낙 쉽고 좋아해서(쉬워서 좋아함..) 그냥 풀 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">lengthOfLongestSubstring&lt;/span>(String sa) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> 0, pointer &lt;span style="color:#f92672">=&lt;/span> 0, max &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>Character&lt;span style="color:#f92672">&amp;gt;&lt;/span> use &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> sa.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> sa.&lt;span style="color:#a6e22e">toCharArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (l &lt;span style="color:#f92672">==&lt;/span> pointer) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (use.&lt;span style="color:#a6e22e">contains&lt;/span>(arr&lt;span style="color:#f92672">[&lt;/span>pointer&lt;span style="color:#f92672">]&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointer &lt;span style="color:#f92672">=&lt;/span> start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> use.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> use.&lt;span style="color:#a6e22e">add&lt;/span>(arr&lt;span style="color:#f92672">[&lt;/span>pointer&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(max, use.&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>pointer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> max;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 메모리 사용률이 엄청 높게 나왔다. 크게 생각하고 푼게 아니라, &lt;code>use&lt;/code> 를 굳이 안쓰고 풀 수 있을텐데, 우선 이대로 제출했다.&lt;/p></description><content>&lt;p>문자열 &lt;code>s&lt;/code> 가 주어졌을 때 겹치는 문자가 없는 부분 문자열의 길이를 반환하라.&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>보자마자 알 수 있었다. Sliding Window 로 풀 수 있다는 것을. Two Pointer 알고리즘은 워낙 쉽고 좋아해서(쉬워서 좋아함..) 그냥 풀 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">lengthOfLongestSubstring&lt;/span>(String sa) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> 0, pointer &lt;span style="color:#f92672">=&lt;/span> 0, max &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>Character&lt;span style="color:#f92672">&amp;gt;&lt;/span> use &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> sa.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> sa.&lt;span style="color:#a6e22e">toCharArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (l &lt;span style="color:#f92672">==&lt;/span> pointer) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (use.&lt;span style="color:#a6e22e">contains&lt;/span>(arr&lt;span style="color:#f92672">[&lt;/span>pointer&lt;span style="color:#f92672">]&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointer &lt;span style="color:#f92672">=&lt;/span> start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> use.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> use.&lt;span style="color:#a6e22e">add&lt;/span>(arr&lt;span style="color:#f92672">[&lt;/span>pointer&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(max, use.&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>pointer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> max;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 메모리 사용률이 엄청 높게 나왔다. 크게 생각하고 푼게 아니라, &lt;code>use&lt;/code> 를 굳이 안쓰고 풀 수 있을텐데, 우선 이대로 제출했다.&lt;/p></content></item><item><title>Leetcode - Container With Most Water</title><link>https://blog.hwajin.me/ko/posts/2022/03/28/leetcode-container-with-most-water/</link><pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate><guid>https://blog.hwajin.me/ko/posts/2022/03/28/leetcode-container-with-most-water/</guid><description>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>You are given an integer array &lt;code>height&lt;/code> of length &lt;code>n&lt;/code>. There are &lt;code>n&lt;/code> vertical lines drawn such that the two endpoints of the &lt;code>ith&lt;/code> line are &lt;code>(i, 0)&lt;/code> and &lt;code>(i, height[i])&lt;/code>.&lt;/p>
&lt;p>Find two lines that together with the x-axis form a container, such that the container contains the most water.&lt;/p>
&lt;p>Return &lt;em>the maximum amount of water a container can store&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Notice&lt;/strong> that you may not slant the container.&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>Two Pointer 로 쉽게 풀 수 있다. 집합의 첫 번째 원소와 마지막 원소를 기준으로 잡고, 더 작은 쪽이 언제나 기준이 된다.&lt;/p></description><content>&lt;h2 id="problem">Problem,&lt;/h2>
&lt;p>You are given an integer array &lt;code>height&lt;/code> of length &lt;code>n&lt;/code>. There are &lt;code>n&lt;/code> vertical lines drawn such that the two endpoints of the &lt;code>ith&lt;/code> line are &lt;code>(i, 0)&lt;/code> and &lt;code>(i, height[i])&lt;/code>.&lt;/p>
&lt;p>Find two lines that together with the x-axis form a container, such that the container contains the most water.&lt;/p>
&lt;p>Return &lt;em>the maximum amount of water a container can store&lt;/em>.&lt;/p>
&lt;p>&lt;strong>Notice&lt;/strong> that you may not slant the container.&lt;/p>
&lt;h2 id="solution">Solution,&lt;/h2>
&lt;p>Two Pointer 로 쉽게 풀 수 있다. 집합의 첫 번째 원소와 마지막 원소를 기준으로 잡고, 더 작은 쪽이 언제나 기준이 된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxArea&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> height) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> 0, right &lt;span style="color:#f92672">=&lt;/span> height.&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1, max &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(left &lt;span style="color:#f92672">&amp;lt;&lt;/span> right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(height&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">]&lt;/span>, height&lt;span style="color:#f92672">[&lt;/span>right&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> (right &lt;span style="color:#f92672">-&lt;/span> left);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (val &lt;span style="color:#f92672">&amp;gt;&lt;/span> max) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max &lt;span style="color:#f92672">=&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (height&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> height&lt;span style="color:#f92672">[&lt;/span>right&lt;span style="color:#f92672">]&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span>right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> max;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item></channel></rss>